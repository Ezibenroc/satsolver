Utilisation
===========

Compilation
-----------

    $ mkdir build/
    $ cd build/
    $ cmake ..
    $ make

Remarque : pour accélérer l’exécution, on peut ajouter « -O3 » à la liste
des options données à g++ (ligne 5 du fichier CMakeLists.txt).

Exécution
---------

La compilation engendre trois exécutables `resol`, `colorie`, et `tseitin`.

Ils peuvent tous prendre les paramètres suivants (qui doivent être avant
les autres paramètres) :

* -verbose pour activer le mode verbeux
* -WL pour activer les litéraux surveillés
* -rand, -moms, ou -dlis (mutuellement exclusifs) pour activer les heuristiques
  du même nom

`colorie` prend également un entier qui est le nombre de couleur maximal à
utiliser.
`tseitin` peut également prendre deux paramètres :
* -print-interpretation qui indique comment le parseur a interprété la
  formule (revient à afficher la même formule, mais avec des parenthèses
  au lieu d’une priorité « implicite »
* -print-sat qui affiche le problème SAT engendré par cette formule.

Enfin, ils peuvent tous prendre un nom de fichier comme dernier paramètre,
qui sert d’entrée (si le nom de fichier n’est pas donné, l’entrée standard
est utilisée).

Les fichiers en entrée de `resol` et `colorie` sont respectivement aux
formats `cnf` et `edge` du DIMACS. Celui de `tseitin` est une formule
telle que définite dans le cours.


Remarque : vu que la sortie de `colorie` est le format d’entrée de `dot`,
on peut utiliser cette commande pour afficher directement le graphe, avec
la commande `display` d’ImageMagick (ou n’importe quel autre programme
lisant du PNG sur son entrée standard) :
 ./colorie 2 example.col | dot -Tpng | display


Tests
-----

Les tests unitaires ne sont compilés *que* si la bibliothèque CppUnit est
installée (libcppunit-dev sous Debian/Ubuntu).
Ils sont compilés en même tempsque les autres exécutables, et sont lancés
par l’exécutable `testrunner`.

Tests en utilisant generator :
Compiler : ocamlc unix.cma -o generator generator_random.ml
Exécuter (en ayant le programme resol dans le répertoire courant) avec 23 tests et 12 variables :
./generator -var 12 -test 23


Implémentation
==============

Organisation du code
--------------------

Les structures de données sont chacunes implémentées dans une paire de
fichiers situés dans src/structures/.
La majorité des opérations effectuables sur ces structures sont
implémentées directement en tant que méthodes de ces objets, ce qui
permet de réduire la taille de l’implémentation de DPLL lui-même et
de s’affranchir complètement de l’implémentation des structures
de données.

Dans le but d’éviter la duplication de code, chaque exécutable
engendré (excepté testrunner) correspond à un des fichiers
de src/entry_points/.

Les formats imposés pour les fichiers CNF et EDGE étant très simples,
ils peuvent être analysés par un simple automate fini,
implémenté dans src/parsers/{abstract,sat,graph}.cpp.

Le format pour les formules étant plus complexe, il faut au moins un
automate à pile pour le reconnaitre, ce qui est fait en utilisant
Flex et Bison, dans src/parsers/extended_formula.*.


Structures de données et choix d’implémentation
-----------------------------------------------

* Clauses :
    * Ensemble de littéraux (unordered_set, basés sur une table de
      hachage, afin d'avoir un accès en temps constant en moyenne).
    * Pointeur vers l'affectation courante de la formule afin de
      pouvoir tester si un littéral est à vrai/faux/indéterminé.
* Affectations :
    * Tableau d'entier, la i-ème case représentant l'état du littéral i.
* Formules :
    * Tableau de clauses.
    * Pointeur sur l'affectation courante.
    * Une pile de couples (entier,booléen). L'entier au sommet est le
      dernier littéral affecté à vrai. Si le booléen associé est true,
      alors c'était une déduction, sinon c'était un pari.
    * Un ensemble de littéraux, qui est l'ensemble des contraintes
      engendrées lors d'une affectation (tous les littéraux de cet ensemble
      doivent être affectés à vrai, et si x et -x sont présents alors
      il y a un conflit).
* Formules étendues :
    * Arbre (évidemment)
    * Éventuellement, si un nœud est étiqueté par =>, une « traduction » en
      un sous-arbre en substituant (A ∨ ¬B) à (A => B). (Pour éviter de la
      recalculer plusieurs fois si on en a besoin)


Comparaison des performances
============================

Avec et sans litéraux surveillés ; sans les heuristiques
--------------------------------------------------------

Le gain des littéraux surveillés est négligeable (voire même légèrement
négatif) sur des instances de 3-SAT (voir les fichiers examples/ex{1,5}-*.cnf)

En revanche, un gain de temps conséquent peut être observé sur de
plus grandes instances, par exemple examples/ex6-unsat.cnf (31s au lieu de
42s)


Heuristiques
------------

[[[[ À REMPLIR ]]]]


Répartition du travail
======================

Tom :
* Structures du rendu 1
* Ajout des littéraux surveillés à l’algorithme de DPLL
* Heuristiques
* Tests de performances, moulinettes

Valentin :
* Parseur de CNF et EDGE
* Algorithme de DPLL (sans les littéraux surveillés)
* Classe et parseur pour les formules étendues ; réduction de Tseitin
* Réduction problème de graphe -> formule étendue
