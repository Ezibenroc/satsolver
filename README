Utilisation
===========

Compilation
-----------

    $ mkdir build/
    $ cd build/
    $ cmake ..
    $ make

Remarque : pour accélérer l’exécution, on peut ajouter « -O3 » à la liste
des options données à g++ (ligne 5 du fichier CMakeLists.txt).

Exécution
---------

La compilation engendre deux exécutables `resol` et `resol-wl`, qui prennent
en paramètre un nom de fichier dans le format de FNC du DIMACS (celui
utilisé par minisat, et détaillé dans l’énoncé du DM1), et affiche en sortie
une solution, dans le format détaillé dans l’énoncé du DM1.

Celui-ci peut également :
* ne pas prendre de nom de fichier en paramètre ; l’entrée standard est
  alors utilisée.
* prendre l’option -verbose en paramètre, qui affiche des informations
  pendant l’exécution de l’algorithme de DPLL.

Tests
-----

Les tests unitaires ne sont compilés *que* si la bibliothèque CppUnit est
installée (libcppunit-dev sous Debian/Ubuntu).
Ils sont compilés en même tempsque les autres exécutables, et sont lancés
par l’exécutable `testrunner`.

Tests en utilisant generator :
Compiler : ocamlc unix.cma -o generator generator_random.ml
Exécuter (en ayant le programme resol dans le répertoire courant) avec 23 tests et 12 variables :
./generator -var 12 -test 23


Implémentation
==============

Organisation du code
--------------------

Les structures de données sont chacunes implémentées dans une paire de
fichiers situés dans src/structures/.
La majorité des opérations effectuables sur ces structures sont
implémentées directement en tant que méthodes de ces objets, ce qui
permet de réduire la taille de l’implémentation de DPLL lui-même et
de s’affranchir complètement de l’implémentation des structures
de données.

Dans le but d’éviter la duplication de code, chaque exécutable
engendré (excepté testrunner) correspond à un des brefs fichiers
de src/entry_points/, qui ne fait qu’utiliser le code écrit dans
src/solver_main.cpp.

Le format imposé étant très simple, il peut être analysé par un simple
automate fini, implémenté dans src/parser.cpp.
Parser::parse appelle Parser::transition (qui lit quelques caractères
du fichier donné en entrée au parseur puis change l’état de l’automate
en fonction de ce qui a été lu) jusqu’à ce que l’état de l’automate
devienne END_OF_FILE (qui est donc l’état final).


Structures de données et choix d’implémentation
-----------------------------------------------

* Clauses :
    * Ensemble de littéraux (unordered_set, basés sur une table de
      hachage, afin d'avoir un accès en temps constant en moyenne).
    * Pointeur vers l'affectation courante de la formule afin de
      pouvoir tester si un littéral est à vrai/faux/indéterminé.
* Affectations :
    * Tableau d'entier, la i-ème case représentant l'état du littéral i.
* Formules :
    * Tableau de clauses.
    * Pointeur sur l'affectation courante.
    * Une pile de couples (entier,booléen). L'entier au sommet est le
      dernier littéral affecté à vrai. Si le booléen associé est true,
      alors c'était une déduction, sinon c'était un pari.
    * Un ensemble de littéraux, qui est l'ensemble des contraintes
      engendrées lors d'une affectation (tous les littéraux de cet ensemble
      doivent être affectés à vrai, et si x et -x sont présents alors
      il y a un conflit).

Répartition du travail
======================

Tom :
* Implémentation des structures
* Ajout des littéraux surveillés à l’algorithme de DPLL

Valentin :
* Implémentation du parseur
* Implémentation de l’algorithme de DPLL (sans les littéraux surveillés)


Comparaison des performance avec et sans les littéraux surveillés
=================================================================

Le gain des littéraux surveillés est négligeable (voire même légèrement
négatif) sur des instances de 3-SAT (voir les fichiers examples/ex{1,5}-*.cnf)

En revanche, un gain de temps conséquent peut être observé sur de
plus grandes instances, par exemple examples/ex6-unsat.cnf (31s au lieu de
42s)
